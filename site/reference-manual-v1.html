<div id="refman">

<div id="refman-sidebar">
  <div id="generated-toc"> </div>
</div>
<div id="refman-main">

<h1>Reference manual</h1>

<p>Soupault (<em>soup-oh</em>) is an HTML manipulation tool.</p>
<p>
It can work either as a static site generator that builds a complete site from a page template
and a directory with page body files, or an HTML processor for an existing website.
</p>
<p>
Soupault is based on HTML element tree rewriting. Pretty much like client-side DOM manipulation, just without the browser or interactivity.
You can tell it to do things like &ldquo;insert contents of <code>footer.html</code> file into
<code>&lt;div id="footer"&gt;</code> no matter where that div is in the page&rdquo;,
or &ldquo;use the first <code>&lt;h1&gt;</code> element in the page for the page title&rdquo;.
</p>

<dl>
  <dt><strong>Full HTML awareness</strong></dt>
  <dd>Soupault is aware of the full page structure. It can find and manipulate any element using
  CSS3 selectors like <code>p</code>, <code>div#content</code>, or <code>a.nav</code>,
  no matter where it is in the page. There is no need &ldquo;front matter&rdquo;&mdash; all metadata
  can be extracted from HTML itself.</dd>
  <dt><strong>No themes</strong></dt>
  <dd>Any page can be a soupault theme, you just tell it where to insert the content.
      By default it inserts page content into the <code>&lt;body&gt;</code> element,
      but it can be anything identifiable with a CSS selector. You decide how much is the &ldquo;theme&rdquo;
      and how much is the content.</dd>
  <dt><strong>Built for text-heavy, nested websites</strong></dt>
  <dd>Tables of contents, footnotes, and breadcrumbs are supported out of the box.
      Existing element id's are respected, so you can make table of contents and footnote links
      permanent and immune to link rot, even if you change the heading text or page structure.</dd>
  <dt><strong>Preserves your content structure</strong></dt>
  <dd>Soupault can mirror your directory structure exactly, down to file extensions.
      You can use it to enhance an existing website without breaking any links, or gradually migrate from an HTML processor
      to the website generator workflow.</dd>
  <dt><strong>Any input format</strong></dt>
  <dd>HTML is the primary format, but you can use anything that can be converted to HTML. Just specify
      preprocessors for files with certain extensions.</dd>
  <dt><strong>Easy to install</strong></dt>
  <dd>Soupault is a single executable file with no dependencies. Just unpack the archive and it's ready to use.</dd>
  <dt><strong>Fast</strong></dt>
  <dd>Soupault is written in <a href="https://ocaml.org">OCaml</a> and compiled to native code on all platforms.
      This website takes less than 0.5 second to build.</dd>
  <dt><strong>Extensible</strong></dt>
  <dd>You can add your own HTML rewriting logic with Lua scripts.</dd>
</dl>

<p>
For a <em>very</em> quick start:
</p>
<ol>
  <li>Create a directory for your site.</li>
  <li>Run <code>soupault --init</code>. It will create a page template in <code>templates/main.html</code>,
      default <code>soupault.conf</code> config file, and a directory for pages (<code>site</code>).</li>
  <li>Drop some HTML files into the <code>site</code> directory.</li>
  <li>Run <code>soupault</code> in that directory.</li>
  <li>Look in <code>build/</code> for the result.</li>
</ol>

<p>For details, read the documentation below.</p>

<h2>Overview</h2>
<p>
Soupault is named after the French dadaist and surrealist writer Philippe Soupault
because it's based on the <a href="https://github.com/aantron/lambdasoup">Lambda Soup</a>
library, which is a reference to the <a href="https://www.crummy.com/software/BeautifulSoup">Beautiful Soup</a>
library, which is a reference to the Mock Turtle chapter from Alice in Wonderland
(the best book on programming for the layman according to Alan Perlis),
which is a reference to an actual turtle soup imitation recipe, and also a reference
to <a href="https://en.wikipedia.org/wiki/Tag_soup">tag soup</a>, a derogatory term
for malformed HTML, which is a reference to... in any case, soupault is not the French
for a stick horse, for better or worse, and this paragraph is the only nod to dadaism
in this document.
</p>
<p>Soupault is quite different from other website generators. Its design goals are:</p>
<ol>
  <li>No special syntax inside pages, only plain old semantic HTML.</li>
  <li>No templates or themes. Any HTML page can be a soupault theme.</li>
  <li>No front matter.</li>
  <li>Usable as a postprocessor for existing website and friendly to sites with unique pages.</li>
</ol>
<p>
People have written lots of static website generators, but most of them are variations
on a single theme: take a file with some metadata (<em>front matter</em>) followed by content in a limited
markup format such as Markdown and feed it to a template processor.
</p>
<p>
This approach works well in many cases, but has its limitations. A template processor is only aware of its
own tags, but not of the full page structure. The front matter metadata is the only part of the
page source it can use, and it can only insert it into fixed locations in the template.
The part below the front matter is effectively opaque, and formats like Markdown simply don't allow you to
add machine-readable annotations anyway.
</p>
<p>
Well-formed HTML, however, is a machine-readable format, and the libraries that can handle it existed for a long time.
As shown by <a href="http://microformats.org/">microformats</a>, you can embed a lot of information in it. More importantly,
unlike front matter metadata, HTML metadata is multi-purpose: for example, you can use the <code>id</code>
attribute for CSS styling and as a page anchor, as well as a unique element identifier for data extraction
or HTML manipulation programs.
</p>
<p>
With soupault, it's possible to take advantage of the full HTML markup and even make every page on your website
look different rather than built from the same template, and still have an automated workflow.
</p>
<p>
You can also use Markdown/reStructuredText/whatever if you specify preprocessors. Soupault will
automatically run a preprocessor before parsing your page, though you'll miss some finer points like footnotes
if you go that way.
</p>
<h3>How soupault works</h3>
<p>
In the website generator mode (the default), soupault takes a page &ldquo;template&rdquo;&mdash;an HTML file devoid of content,
parses it into an element tree, and locates the <em>content container</em> element inside it.
</p>
<p>
By default the content container is <code>&lt;body&gt;</code>, but you can use any selector:
<code>div#content</code> (a <code>&lt;div id="content"&gt;</code> element), <code>article</code> (an HTML5 article element),
<code>#post</code> (any element with <code>id="post"</code>) or any other valid CSS selector.
</p>
<p>
Then it traverses your <em>site directory</em> where page source files are stored, takes a page file, and parses it into an HTML element tree too.
If the file is not a complete HTML document (doesn't have an <code>&lt;html&gt;</code> element in it),
soupault inserts it into the <em>content container</em> element of the template. If it is a complete page, then it goes straight to the next step.
</p>
<p>
The new HTML tree is then passed to <em>widgets</em>&mdash;HTML rewriting modules that manipulate it in different ways:
include other files or outputs of external programs into specific elements, create breadcrumbs for your page,
they may delete unwanted elements too.
</p>
<p>
Processed pages are then written to disk, into a directory structure that mirrors your source
directory structure.
</p>
<p>Here is a simplified flowchart:</p>
<img src="/images/soupault_flowchart.png" alt="soupault flowchart" />

<h3>Performance</h3>
<p>
Despite its heavy-handed approach, soupault is reasonably fast. With a config that includes ToC, footnotes, file inclusion,
breadcrumbs, and built-in section index generator, it can process 1000 copies of its own documentation page
in about 14 seconds.<span class="footnote" id="benchmark-machine">On my desktop with an i5-7260U CPU and a magnetic drive.</span>
Small websites take less than a second to build.
</p>
<p>
For comparison, in a simplified &ldquo;read-parse-prettify-write&rdquo; test with 1000 copies of this document, 
CPython/BeautifulSoup takes about 20 seconds to complete.
</p>

<h3>Why use soupault?</h3>

<h4>If you are starting a website</h4>
<p>
All website generators provide a default theme, but making new themes can be tricky.
With soupault, there are no intermediate steps between writing your page layout and building
your website from it.
</p>
<p>
In the simplest case you can just create a page skeleton in <code>templates/main.html</code> with an empty <code>&lt;body&gt;</code>,
add a bunch of pages to <code>site/</code> (<code>site/about.html</code>, <code>site/cv.html</code>, ...)
and run the <code>soupault</code> command in that directory.
</p>

<h4>If you already have a website</h4>
<p>
If you have a website made of handwritten pages, you can use soupault as a drop-in automation tool.
Just copy your pages to the <code>site</code> directory, and you can already take advantages of features like
tables of content, without modifying any of your pages.
</p>
<p>
Then you can gradually migrate to using a shared template, if you want to. Take a page, remove the content from it, save that empty page
to <code>templates/main.html</code>, and start stripping pages in <code>site</code> down to their content.
Pages that don't have an <code>&lt;html&gt;</code> element will be treated as page bodies and inserted in the template,
but other pages will only be processed by widgets.
</p>
<p>
If you have an existing directory structure that you don't want to change because it will break links,
soupault can mirror it exactly, with the <code>clean_urls = false</code> config option.
It also preserves original file names and extensions in that mode.
</p>

<h3>What can it do?</h3>
<p>
Soupault comes with a bunch of built-in widgets that can:
</p>
<ul>
  <li>Include external files, HTML snippets, or output of external programs into an element.</li>
  <li>Set the page title from text in some element.</li>
  <li>Generate breadcrumbs.</li>
  <li>Move footnotes out of the text.</li>
  <li>Insert a table of contents.</li>
  <li>Delete unwanted elements.</li>
</ul>
<p>For example, here's a config for the <code>title</code> widget that sets the page title.</p>
<pre class="language-toml">
[widgets.page-title]
  widget = "title"
  selector = "#title"
  default = "My Website"
  append = " &amp;mdash; My Website"
</pre>
<p>
It takes the text from the element with <code>id="title"</code> and copies it to the <code>&lt;title&gt;</code>
tag of the generated page. It can be any element, and it can be a different element in every page.
If you use <code>&lt;h1 id="title"&gt;</code> in <code>site/foo.html</code> and <code>&lt;strong id="title"&gt;</code>
in another, soupault will still find it.
</p>
<p>It's just as simple to prevent something from appearing on a particular page. Just don't use an element
that a widget uses for its target, and the widget will not run on that page.
</p>
<p>
Another example: to automatically include content of a <code>templates/nav-menu.html</code> into
the <code>&lt;nav&gt;</code> element, you can put this into your <code>soupault.conf</code> file:
</p>
<pre class="language-toml">
[widgets.nav-menu]
  widget = "include"
  selector = "nav"
  file = "templates/nav-menu.html"
</pre>

<h3>What it cannot do</h3>

<p>By design:</p>
<dl>
  <dt>Development web server</dt>
  <dd>There are plenty of those, even <code>python3 -m http.server</code> is perfectly
      good for previews.</dd>
  <dt>Deployment automation.</dt>
  <dd>Same reason, there are lots of tools for it.</dd>
</dl>

<p>Because I don't need it and I'm not sure if anyone wants it or how it will fit:</p>
<ul>
  <li>Asset management</li>
  <li>Incremental builds</li>
  <li>Multilingual sites</li>
</ul>

<h2>Installation</h2>
<h3>Binary release packages</h3>
<p>
Soupault is distributed as a single, self-contained executable, so installing it from a binary release package
it trivial.
</p>
<p>
You can download it
from <a href="https://files.baturin.org/software/soupault">files.baturin.org/software/soupault</a>.
Prebuilt executables are available for Linux (x86-64, statically linked), macOS (x86-64), and Microsoft Windows (32-bit, Windows 7 and newer).
</p>
<p>
Just unpack the archive and copy the executable wherever you want.
</p>
<p>
Prebuilt executables are compiled with debug symbols.
It makes them a couple of megabytes larger than they could be, but you can get better
error messages if something goes wrong. If you encounter an internal error, you can get an exception trace
by running it with <code>OCAMLRUNPARAM=b</code> environment variable.
</p>

<h3>Building from source</h3>
<p>
If you are familiar with the <a href="https://ocaml.org">OCaml</a> programming language, you may want to install
from source.
</p>
<p>
Since version 1.6, soupault is available from the <a href="https://opam.ocaml.org/packages/soupault/">opam repository</a>.
If you already have opam installed, you can install it with <code>opam install soupault</code>.
</p>
<p>
If you want the latest development version, the git repository is at <a href="https://github.com/dmbaturin/soupault">github.com/dmbaturin/soupault</a>.
</p>
<p>
To build a statically linked executable for Linux, identical to the official one, first install a <code>+musl+static+flambda</code>
compiler flavor, then uncomment the <code>(flags (-ccopt -static))</code> line in <code>src/dune</code>.
</p>

<h3>Using soupault on Windows</h3>
<p>
Windows is a supported platform and soupault includes some fixups to account for the differences. This document
makes a UNIX cultural assumption throughout, but most of the time the same configs will work on both systems.
Some differences, however, require user intervention to resolve.
</p>
<p>
If a file path is only used by soupault itself, then the UNIX convention will work, i.e.
<code>file = 'templates/header.html'</code> and <code>file = 'templates\header.html'</code> are both valid options
for the <code>include</code> widget. However, if it's passed to something else in the system, then you <strong>must</strong>
use the Windows convention with back slashes. This applies to the preprocessors, the <code>command</code> option of the
<code>exec</code> widget, and the <code>index_processor</code> option.
</p>
<p>So, if you are on Windows, remember to adjust the paths if needed, e.g.:
<pre class="language-toml">
[widgets.some-script]
  widget = 'exec'
  command = 'scripts\myscript.bat'
  selector = 'body'
</pre>
<p>
Note that inside double quotes, the back slash is an escape character, so you should either use single quotes for such paths
(<code>'scripts\myscript.bat'</code>) or use a double back slash (<code>"scripts\\myscript.bat"</code>).
</p>

<h2>Getting started</h2>
<h3>Create your first website</h3>
<p>
Soupault has only one file of its own: the config file <code>soupault.conf</code>.
It does not impose any particular directory layout on you. However, it has default
settings that allow you to run it unconfigured.
</p>
<p>You can initialize a simple project with default configuration using this command:</p>
<pre>
$ soupault --init
</pre>
<p>It will create the following directory structure:</p>
<pre>
.
├── site
│   └── index.html
├── templates
│   └── main.html
└── soupault.conf
</pre>
<ul>
  <li>The <code>site/</code> is a <em>site directory</em> where page files are stored.</li>
  <li>The <code>templates/</code> directory is just a convention, soupault uses <code>templates/main.html</code>
      as the default page template.</li>
  <li><code>soupault.conf</code> is the config file.</li>
</ul>
<p>
Now you can build your website. Just run <code>soupault</code> in your website directory,
and it will put the generated pages in <code>build/</code>. Your index page will become
<code>build/index.html</code>.
</p>
<p>
By default, soupault inserts page content into the <code>&lt;body&gt;</code> element
of the page template. Therefore, from the default template:
</p>
<pre class="language-html">
&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body&gt;
  &lt;!-- your page content here --&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
and the default index page source that is <code>&lt;p&gt;Site powered by soupault&lt;/p&gt;</code>
it will make this page:
</p>
<pre class="language-html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
 &lt;head&gt;&lt;/head&gt;
 &lt;body&gt;
  &lt;p&gt;
   Site powered by soupault
  &lt;/p&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
You can use any CSS selector to determine where your content goes. For example,
you can tell soupault to insert it into <code>&lt;div id="content&gt;</code>
by changing the <code>content_selector</code> in <code>soupault.conf</code>
to <code>content_selector = "div#content"</code>.

<h3>Page files</h3>
<p>
Soupault assumes that files with extensions <code>.html, .htm, .md, .rst, and .adoc</code> are pages
and processes them. All other files are simply copied to the build directory.
</p>
<p>
If you want to use other extensions, you can change it in <code>soupault.conf</code>.
For example, to add <code>.txt</code> to the page extension list, use this option:
</p>
<pre class="language-toml">
[settings]
  page_file_extensions = ["htm", "html", "md", "rst", "txt"]
</pre>
<p>
Remember that for files in formats other than HTML, you also need to specify a <a href="#Page preprocessors">converter</a>,
simply adding an extension to the list is not enough.
</p>

<h3>Clean URLs</h3>
<p>
Soupault uses clean URLs by default. If you add another page to <code>site/</code>,
for example, <code>site/about.html</code>, it will turn into <code>build/about/index.html</code>
so that it can be accessed as <code>https://mysite.example.com/about</code>.
</p>
<p>
Index files, by default files whose name is <code>index</code> are simply copied to the target
directory.
</p>
<pre>
site/index.html → build/index.html
site/about.html → build/about/index.html
site/papers/theorems-for-free.html → build/papers/theorems-for-free/index.html
</pre>
<div class="info">
<p>
Note: a page named <code>foo.html</code> and a section directory named <code>foo/</code> is
undefined behaviour when clean URLs are used. Don't do that to avoid unpredictable results.
</p>
</div>
<p>This is what soupault will make from a source directory:</p>
<pre>
$ tree site/
site/
├── about.html
├── cv.html
└── index.html

$ tree build/
build/
├── about
│   └── index.html
├── cv
│   └── index.html
└── index.html
</pre>

<h4>Disabling clean URLs</h4>
<p>
If you've had a website for a long time and there are links to your page that will
break if you change the URLs, you can make soupault mirror your site directory structure
exactly and preserve original file names.
</p>
<p>
Just add <code>clean_urls = false</code> to the <code>[settings]</code> table of your
<code>soupault.conf</code> file.
</p>
<pre class="language-toml">
[settings]
  clean_urls = false
</pre>

<h3>Soupault as an HTML processor</h3>
<p>
If you want to use soupault with an existing website and don't want the template functionality,
you can switch it from a website generator mode to an HTML processor more where it doesn't use
a template and doesn't require the <code>default_template</code> to exist.
</p>
<p>Recommended settings for the preprocessor mode:</p>
<pre class="language-toml">
[settings]
  generator_mode = false
  clean_urls = false
</pre>

<h3>Page templates</h3>
<p>
Some people want all their pages to have a consistent look, and then having just a <code>default_template</code>
option works perfectly. Some people prefer to give every page a unique look, and then disabling generator mode
is a right thing to do. Yet a third category of people want just some pages or sections to look different.
</p>
<p>
For this use case, soupault supports multiple page templates. You can define them in the <code>[templates]</code>
section.
</p>

<pre class="language-toml">
[templates.serious-template]
  file = "templates/serious.html"
  section = "serious-business"

[templates.fun-template]
  file = "templates/fun.html"
  path_regex = "(.*)/funny-(.*)"
</pre>

<p>
As of soupault 1.12, there is no way to specify a <code>content_selector</code> option per template,
and they all will use the <code>content_selector</code> option from <code>[settings]</code>.
</p>
<p>Page/section targeting options are discussed in detail in the <a href="#limiting-widgets-to-pages-or-sections">widgets section</a>.</p>
<p>
Note that proper template targeting is your responsibility. Omitting the <code>page, section, path_regex</code> option will not cause errors,
but soupault may use a wrong template for some pages. If that happens, make your targeting options more specific. 
</p>


<h3>Nested structures</h3>
<p>
A flat layout is not always desirable. If you want to create site sections, just add some
directories to <code>site/</code>. Subdirectories are subsections, their subdirectories
are subsubsections and so on&mdash;they can go as deep as you want. Soupault will process
them all recursively and recreate the directories in <code>build/</code>.
</p>

<pre>
site/
├── articles
│   ├── goto-considered-harmful.html
│   ├── index.html
│   └── theorems-for-free.html
├── about.html
├── cv.html
└── index.html

build/
├── about
│   └── index.html
├── articles
│   ├── goto-considered-harmful
│   │   └── index.html
│   ├── theorems-for-free
│   │   └── index.html
│   └── index.html
├── cv
│   └── index.html
└── index.html
</pre>
<div class="info">
<p>
Note that if your section does not have an index page, soupault will not create it automatically.
If you want a page to exist, you need to make it.
</p>
</div>

<h2>Configuration</h2>
<p>
The default directory and file paths <code>soupault --init</code> creates are
not fixed, you can change any of them. If you prefer different names, or you
have an existing directory structure you want soupault to use, just edit
the <code>soupault.conf</code> file. This is <code>[settings]</code> section of the default config:
</p>
<pre class="language-toml">
[settings]
  # Stop on page processing errors?
  strict = true

  # Display progress?
  verbose = false

  # Display detailed debug output?
  debug = false

  # Where input files (pages and assets) are stored.
  site_dir = "site"

  # Where the output goes
  build_dir = "build"

  # Files inside the site/ directory can be treated as pages or static assets,
  # depending on the extension.
  #
  # Files with extensions from this list are considered pages and processed.
  # All other files are copied to build/ unchanged.
  #
  # Note that for formats other than HTML, you need to specify an external program
  # for converting them to HTML (see below).
  page_file_extensions = ["htm", "html", "md", "rst", "adoc"]

  # Files with these extensions are ignored.
  ignore_extensions = ["draft"]

  # Soupault can work as a website generator or an HTML processor.
  #
  # In the "website generator" mode, it considers files in site/ page bodies
  # and inserts them into the empty page template stored in templates/main.html
  #
  # Setting this option to false switches it to the "HTML processor" mode
  # when it considers every file in site/ a complete page and only runs it through widgets/plugins.
  generator_mode = false

  # Files that contain an <html> element are considered complete pages rather than page bodies,
  # even in the "website generator" mode.
  # This allows you to use a unique layout for some pages and still have them processed by widgets.
  complete_page_selector = "html"

  # Website generator mode requires a page template (an empty page to insert a page body into).
  # If you use "generator_mode = false", this file is not required.
  #default_template = "templates/main.html"

  # Page content is inserted into a certain element of the page template. This option is a CSS selector
  # used for locating that element.
  # By default the content is inserted into the <body>
  content_selector = "body"

  # Soupault currently doesn't preserve the original doctype declaration
  # and uses the HTML5 doctype by default. You can change it using this option.
  doctype = "<!DOCTYPE html>"

  # Enables or disables clean URLs.
  # When false: site/about.html -> build/about.html
  # When true: site/about.html -> build/about/index.html
  clean_urls = true

  # Since 1.10, soupault has plugin auto-discovery
  # A file like plugins/my-plugin.lua will be registered as a widget named my-plugin
  plugin_discovery = true
  plugin_dirs = ["plugins"]
</pre>

<p>
Note that if you create <code>soupault.conf</code> file before running
<code>soupault --init</code>, it will use settings from that file instead
of default settings.
</p>
<p>
In this document, whenever a specific site or build dir has to be mentioned,
we'll use default values.
</p>
<div class="info">
<p>
If you misspell and option or make another mistake, soupault will warn you about
an invalid option and try to suggest a correction.
</p>
<p>
Note that the config is typed and wrong value type has the same effect as missing
option. All boolean values must be <code>true</code> or <code>false</code>
(without quotes), all integer values must not have quotes around numbers,
and all strings must be in single or double quotes.
</p>
</div>

<h3>Custom directory layouts</h3>
<p>
If you are using soupault as an HTML processor, or using it as a part of a CI pipeline,
the typical website generator approach with a single &ldquo;project directory&rdquo;
may not be optimal.
</p>
<p>
You can override the location of the config using an environment variable <code>SOUPAULT_CONFIG</code>.
You can also override the locations of the source and destination directories with <code>--site-dir</code>
and <code>--build-dir</code> options. Thus it's possible to run soupault without a dedicated project
directory at all:
</p>
<pre>
SOUPAULT_CONFIG="something.conf" soupault --site-dir some-input-dir --build-dir some-other-dir
</pre>

<h2>Page preprocessors</h2>
<p>
Soupault has no built-in support for formats other than HTML, but you can use
any format with it if you specify an appropriate page preprocessor.
</p>
<p>
Any preprocessor that takes page file as its argument and outputs the result to
<code>stdout</code> can be used.
</p>
<p>
For example, this configuration will make soupault call a program called
<code>cmark</code> on the page file if its extension is <code>.md</code>.
<pre class="language-toml">
[preprocessors]
  md = "cmark"
</pre>
<p>
The table key can be any extension (without the dot), and the value is a command.
You can specify as many extensions as you want.
</p>
<p>
Preprocessor commands are executed in shell, so it's fine to use relative
paths and add arguments. Page file name will be appended to the command string.
</p>
<p>
By default soupault assumes that files with extensions <code>.md, .rst, .adoc</code>
are pages. If you are using another extension, you need to add it to the
<code>page_file_extensions</code> list in the <code>[settings]</code> section,
else it will assume it's an asset and copy it unmodified, even if you configure a preprocessor
for that extension.
</p>

<h2 id="indexing">Automatic section and site index</h2>
<p>
Having to add links to all pages by hand can be a tedious task. Nothing beats
a carefully written and annotated section index, but it's not always practical.
</p>
<p>
Soupault can automatically generate a section index for you. While it's not a blog
generator and doesn't have built-in features for generating indices of pages by date, category etc.,
it can save you time writing a section index pages by hand.
</p>
<p>
Metadata is extracted directly from pages using selectors you specify in the
config. It's more than possible to use a different element for excerpt in every page,
not just the first paragraph, without having to duplicate it in the &ldquo;front matter&rdquo;.
It doesn't even have to be text either. Same goes for other fields.
</p>
<p>
To use automatic indexing, you still need an index page in your section.
It can be empty, but it must be there. Default index page name is <code>index</code>,
so you should make a page like <code>site/articles/index.html</code> first.
</p>
<p>Then enable indexing in the config. All indexing options are in the <code>[index]</code> table.</p>
<pre class="language-toml">
[index]
  index = true
</pre>
<p>
By default, soupault will append the index to the <code>&lt;body&gt;</code> element.
You can tell it to insert it anywhere you want with the <code>index_selector</code>
option, e.g. <code>index_selector = "div#index"</code>.
</p>
<p>
There are a few configurable options. You can specify element selectors for page title,
excerpt, date, and author.
</p>
<p>These are all available options:</p>
<pre class="language-toml">
[index]
  # Whether to generate indices or not
  # Default is false, set to true to enable
  index = false

  # Where to insert the index
  index_selector = "body"

  # Page title selector
  index_title_selector = "h1"

  # Page excerpt selector
  index_excerpt_selector = "p"

  # Page date selector
  index_date_selector = "time"

  # By default entries are sorted by date in ascending order (oldest to newest)
  # If you are making a blog, you can set this to true to sort from newest to oldest
  newest_entries_first = false

  # Date format for sorting
  # Default %F means YYYY-MM-DD
  # For other formats, see http://calendar.forge.ocamlcore.org/doc/Printer.html
  index_date_format = "%F"

  # Page author selector
  index_author_selector = "#author"

  # Mustache template for index entries
  index_item_template = "&lt;div&gt; &lt;a href=\"{{url}}\"&gt;{{{title}}}&lt;/a&gt; &lt;/div&gt;"

  # External index generator
  # There is no default
  index_processor = 

  # When false, causes soupault to ignore index_item_template and index_processor
  # options (and their default values). Useful if you want to use named views exclusively.
  use_default_view = true
</pre>
<h3>Built-in index generator</h3>
<p>
Since version 1.6, soupault includes a built-in index generator that uses Mustache templates.
</p>
<p>
The following built-in fields are supported: <code>url, title, excerpt, date, author</code>.
For a simple blog feed, you can use something like this:
</p>
<pre class="raw-html">
index_item_template = """
    <h2><a href="{{url}}">{{title}}</a></h2>
    <p><strong>Last update:</strong> {{date}}.</p>
    <p>{{{excerpt}}}</p>
    <a href="{{url}}">Read more</a>
  """
</pre>
<p>
If you define <a href="#custom-index-fields">custom fields</a>, they also become available to the Mustache renderer.
An easy way to see what fields are available to the built-in and external generators is to run <code>soupault --debug</code>,
which prints a JSON dump of the index data among other things.
</p>

<h3>External index generators</h3>
<p>
The built-in index generator simply copies elements from the page to the index.
You can easily end up with a rather odd-looking index, especially if you are
using different elements on every page and identify them by <code>id</code>
rather than element name.
</p>
<p>
Generating indices and blog feeds is where template processors really shine.
Everyone has different preferences though, so instead of having a built-in
template processor, soupault supports exporting the index to JSON and
feeding it to an external program.
</p>
<p>
JSON-encoded index is written to program's standard input, as a single line.<span class="footnote" id="pipe-newlines">
Newline as end of message is a horrible protocol, but since there's no universally
agreed upon alternative for sending structured data to stdin, that's what we've got.</span>
It's a list of objects with following fields:
</p>
<dl>
  <dt><code>url</code></dt>
  <dd>Absolute page URL path, like <code>/papers/simple-imperative-polymorphism</code></dd>
  <dt><code>nav_path</code><dt>
  <dd>A list of strings that represents the logical section path, e.g. for <code>/pictures/cats/grumpy</code>
  it will be <code>["pictures", "cats"]</code>.</dd>
  <dt><code>title, date, excerpt, author</code><dt>
  <dd>Metadata extracted from the page. Any of them can be <code>null</code>.</dd>
  <dt><code>page_file</code></dt>
  <dd>Original page file path.</dd>
</dl>
<p>
Here's an example of very simple indexing setup that will take the first <code>h1</code>
of every page in a section and make an unordered list of links to them. The external
processor will use Python and <a href="https://mustache.github.io/">Mustache</a>
templates.
</p>
<p>
First, create an <code>index.html</code> page in every section and include a
<code>&lt;div id="index"&gt;</code> element in it.
</p>
<p>Then write this to your config file:</p>
<pre class="language-toml">
[index]
  index = true
  index_selector = "#index"
  index_processor = "scripts/index.py"
  index_title_selector = "h1"
</pre>
<p>
Then install the <code>pystache</code> library and save this script to <code>scripts/index.py</code>:
</p>
<pre class="language-python">
#!/usr/bin/env python3

import sys
import json

import pystache

template = """
&lt;li&gt;&lt;a href="{{url}}"&gt;{{title}}&lt;/a&gt;&lt;/li&gt;
"""

renderer = pystache.Renderer()

input = sys.stdin.readline()
index_entries = json.loads(input)

print("&lt;ul class=\"nav\"&gt;")
for entry in index_entries:
    print(renderer.render(template, entry))
print("&lt;/ul&gt;")
</pre>
<p>
Index processors are not required to output anything. You can as well use
them to save the index data somewhere and create taxonomies and custom indices from it with
another script,
then re-run soupault to have them included in the pages.<span class="footnote" id="tex-like-toc">TeX users are familiar with this approach.</span>
</p>

<h3>Multiple index views</h3>
<p>
Since version 1.7, soupault supports multiple index &ldquo;views&rdquo; that allows you to present the same index data in different ways.
For example, you can have a blog feed in <code>/blog</code>, but a simple list or pages in every other section.
</p>
<p>
Views are defined in the <code>[index.views]</code> table. You can use either normal or inline table syntax, from TOML's point of view
it's the same. Example:
</p>
<pre class="language-toml">
[index.views.title-and-date]
  index_selector = "div#index-title-date"
  index_item_template = "&lt;li&gt; &lt;a href=\"{{url}}\"&gt;{{{title}}}&lt;/a&gt; ({{date}})&lt;/li&gt;"

[index.views.custom]
  index_selector = "div#custom-index"
  index_processor = 'scripts/my-index-generator.pl'
</pre>
<p>
Which view is used is determined by the <code>index_selector</code> option. In this example, if your section index page
has a <code>&lt;div id="index-title-date"&gt;</code>, soupault will insert an index generated by the <code>title-and-date</code> view,
and if it has a <code>&lt;div id="index-custom"&gt;</code>, it will insert the output of <code>scripts/my-index-generator.pl</code>.
</p>
<p>
If your page has <em>both</em> elements, both index views will be inserted in their containers. This may be useful if you want to include
different views in the same page, e.g. show articles grouped by date and by author.
</p>
<p>
Note that defining custom views doesn't automatically make soupault ignore <code>index_item_template</code> and <code>index_processor</code>
options from the <code>[index]</code> table. Since the <code>index_item_template</code> option has a default value, and <code>index_selector</code>
defaults to <code>"body"</code>, you may end up with an unwanted index at the top of your page if you leave the global <code>index_selector</code>
option undefined. If you want to use named views exclusively, add <code>use_default_view = true</code> to the <code>[index]</code> table.
</p>

<h3 id="custom-index-fields">Custom fields</h3>
<p>
Built-in fields should be enough for a typical blog taxonomy, but it's possible
to add custom fields to your JSON index data.
</p>
<p>
Custom field queries are defined in the <code>[index.custom_fields]</code> table.
Table keys are field names as they will appear in the exported JSON.
Their values are subtables with required <code>selector</code> field
and optional <code>select_all</code> parameters.
</p>
<p>
You can also specify default value for a field that will be used if matching element
is not found, using <code>default</code> option. For fields with <code>select_all</code>
flag, default value is ignored.
</p>
<pre class="language-toml">
[index.custom_fields]
  category = { selector = "span#category", default = "misc" }

  tags = { selector = ".tag", select_all = true }
</pre>
<p>
In this example, the <code>category</code> field will contain the inner HTML
of the first <code>&lt;span id="category"&gt;</code> element even if there's
more than one in the page (if there are none, it will be set to "misc").
The <code>tags</code> field will contain a list of contents of all elements with <code>class="tag"</code>.
</p>

<h3>Exporting site index to JSON</h3>
<p>
The index processor invoked with the <code>index_processor</code> option
receives the index of the current section. It doesn't include subsections.
Since the site directory is processed top to bottom, the <code>site/index.html</code>
page would not get the global site index either.
</p>
<p>
If you want to create your own taxonomies from the metadata imported from pages,
create a global site index, or an index of a section and all its subsections,
you can export the aggregated index data to a file for further processing.
Add this option to your index config:
</p>
<pre class="language-toml">
[index]
  dump_json = "path/to/file.json"
</pre>
<p>This way you can use a TeX-like workflow:</p>
<ol>
  <li>Run soupault so that index file is created.</li>
  <li>Run your custom index generator and save generated taxonomy pages to <code>site/</code>.</li>
  <li>Run soupault one more time to have them included in the build.</li>
</ol>

<h3>Behaviour</h3>
<p>
As of 1.6, generated index is always inserted before any widgets have run, so that the HTML produced
by index generators can be processed by widgets.
</p>
<p>
Metadata extraction happens as early as possible. By default, it happens <em>before</em> any widgets have run,
to avoid adverse interaction with widgets. However, if you want data inserted by widgets to be available
in the index, you can make soupault do the extraction after certain widgets with a <code>extract_after_widgets = ["foo", "bar"]</code>
option in the <code>[index]</code> table.
</p>
<p>
Note that it doesn't mean no other widgets will run before metadata is extracted. It only means metadata will not be extracted
until widgets specified in the <code>extract_after_widgets</code> option have run. So, if you want a widget to run only
after metadata is extracted, you should specify all those widgets in its dependencies. There is no easier way to do that now.
</p>

<h3>Limiting index extraction to pages or sections</h3>
<p>
Since soupault 1.9, you can extract index data only from some pages/sections, or exclude specific pages/sections from indexing.
The options are the same as for <a href="#limiting-widgets-to-pages-or-sections">widgets</a>.
</p>

<h3>Extracting the index without generating pages</h3>
<p>
Since 1.9, soupault supports <code>--index-only</code> option. In the index-only mode, it will extract the index data from pages
and save it in JSON, but will not generate any pages. It will only run widgets that must run before index extraction.
if you have <code>extract_after_widgets</code> option configured.
</p>

<h2>Widgets</h2>

<p>
Widgets provide additional functionality. When a page is processed, its content
is inserted into the template, and the resulting HTML element tree is passed
through a widget pipeline.
</p>
<h3>Widget behaviour</h3>
<p>
Widgets that require a <code>selector</code> option first check if there's an element matching
that selector in the page, and do nothing if it's not found, since they wouldn't
have a place to insert their output.
</p>
<p>
This way you can avoid having a widget run on a page simply by omitting the element
it's looking for.
</p>
<p>
If more than one element matches the selector, the first element is used.
</p>

<h3>Widget configuration</h3>
<p>
Widget configuration is stored in the <code>[widgets]</code> table. The TOML syntax
for nested tables is <code>[table.subtable]</code>, therefore, you will have entries
like <code>[widgets.foo]</code>, <code>[widgets.bar]</code> and so on.
</p>
<p>
Widget subtable names are purely informational and have no effect, the widget type
is determined by the <code>widget</code> option. Therefore, if you want to use
a hypothetical <code>frobnicator</code> widget, your entry will look like:
</p>
<pre class="language-toml">
[widgets.frobnicate]
  widget = "frobnicator"
  selector = "div#frob"
</pre>
<p>
It may seem confusing and redundant, but if subtable name defined the
widget to be called, you could only have one widget of the same type,
and would have to choose whether to include the header or the footer
with the <code>include</code> widget for example.
</p>

<h3>Choosing where to insert the output</h3>
<p>By default, widget output is inserted after the last child element in its container.</p>
<p>
If you have a designated place in your page for the widget output,
e.g. leave an empty <code>&lt;div id="header"&gt;</code> for the header,
then this detail is unimportant.
</p>
<p>
However, if you are modifying existing pages or just want more control and flexibility,
you can specify the insert position using the <code>action</code> option.
</p>
<p>For example, you can insert a header file before the first element in the page <code>&lt;body&gt;</code>:
<pre class="language-toml">
[widgets.insert-header]
  widget = "include"
  file = "templates/header.html"
  selector = "body"
  action = "prepend_child"
</pre>
<p>
Or insert a table of contents before the first <code>&lt;h1&gt;</code> element (it a page has it):
</p>
<pre class="language-toml">
[widgets.table-of-contents]
  widget = "toc"
  selector = "h1"
  action = "insert_before"
</pre>
<p>
Possible values of that option are: <code>prepend_child, append_child, insert_before, insert_after, replace_element, replace_content</code>.
</p>

<h3>Limiting widgets to pages or sections</h3>
<p>
If the widget target comes from the page content rather than the template,
you can simply not include any elements matching its <code>selector</code>
option.
</p>
<p>
Otherwise, you can explicitly set a widget to run or not run on specific
pages or sections.
</p>
<p>
All options from this section can take either a single string, or a list
of strings.
</p>

<h4>Limiting to pages or sections</h4>
<p>
There are <code>page</code> and <code>section</code> options that 
allow you to specify exact paths to specific pages or sections.
Paths are relative to your site directory.
</p>
<p>
The <code>page</code> option limits a widget to an exact page file,
while the <code>section</code> option applies a widget to all
files in a subdirectory.
</p>
<pre class="language-toml">
[widgets.site-news]
  # only on site/index.html and site/news.html
  page = ["index.html", "news.html"]

  widget = "include"
  file = "includes/site-news.html"
  selector = "div#news"

[widgets.cat-picture]
  # only on site/cats/*
  section = "cats"

  widget = "insert_html"
  html = "&lt;img src=\"/images/lolcat_cookie.gif\" /&gt;"
  selector = "#catpic"
</pre>

<h4>Excluding sections or pages</h4>
<p>
It's also possible to explicitly exclude pages or sections.
</p>
<pre class="language-toml">
[widgets.toc]
  # Don't add a TOC to the main page
  exclude_page = "index.html"
  ...

[widgets.evil-analytics]
  exclude_section = "privacy"
  ...
</pre>

<h4>Using regular expressions</h4>

<p>
When nothing else helps, <code>path_regex</code> and <code>exclude_path_regex</code> options
may solve your problem. They take a Perl-compatible regular expression (not a glob).
</p>

<pre class="language-toml">
[widgets.toc]
  # Don't add a TOC to any section index page
  exclude_path_regex = '^(.*)/index\.html$'
  ...

[widgets.cat-picture]
  path_regex = 'cats/'
</pre>

<h3>Widget processing order</h3>
<p>
The order of widgets in your config file doesn't determine their processing order.
By default, soupault assumes that widgets are independent and can be processed in arbitrary order.
In future versions they may even be processed in parallel, who knows.
</p>
<p>
This can be an issue if one widget relies on output from another. In that case,
you can order widgets explicitly with the <code>after</code> parameter.
It can be a single widget (<code>after = "mywidget"</code) or a list of widgets
(<code>after = ["some-widget", "another-widget"]</code>).
</p>
<p>
Here is an example. Suppose in the template there's
a <code>&lt;div id="breadcrumbs"&gt;</code> where breadcrumbs are inserted by the
<code>add-breadcrumbs</code> widget. Since there may not be breadcrumbs if the
page is not deep enough, the <code>div</code> may be left empty, and that's not
<em>neat</em>, so the <code>cleanup-breadcrumbs</code> widget removes it.
</p>
<pre class="language-toml">
## Breadcrumbs
[widgets.add-breadcrumbs]
  widget = "breadcrumbs"
  selector = "#breadcrumbs"
  # <omitted>

## Remove div#breadcrumbs if the breadcrumbs widget left it empty
[widgets.cleanup-breadcrumbs]
  widget = "delete_element"
  selector = "#breadcrumbs"
  only_if_empty = true

  # Important!
  after = "add-breadcrumbs"
</pre>

<h3>Limiting widgets to &ldquo;build profiles&rdquo;</h3>
<p>
Sometimes you may want to enable certain widgets only for some builds. For example, include analytics
scripts only in production builds. It can be done with &ldquo;build profiles&rdquo;.
</p>
<p>
For example, this way you can only include <code>includes/analytics.html</code> file in your pages
for a build profile named &ldquo;live&rdquo;:
</p>
<pre class="language-toml">
[widgets.analytics]
  profile = "live"
  widget = "include"
  file = "includes/analytics.html"
  selector = "body"
</pre>
<p>
Soupault will only process that widget if you run <code>soupault --profile live</code>. If you run
<code>soupault --profile dev</code>, or run it without the <code>--profile</code> option, it will ignore that widget.
</p>

<h2>Built-in widgets</h2>
<h3>File and output inclusion</h3>
<p>These widgets include something into your page: a file, a snippet, or output of an external program.</p>
<h4 id="widgets-include">include</h4>
<p>
The <code>include</code> widget simply reads a file and inserts its content
into some element.
</code>
<p>
The following configuration will insert the content of <code>templates/header.html</code>
into an element with <code>id="header"</code> and the content of <code>templates/footer.html</code>
into an element with <code>id="footer"</code>.
</p>
<pre class="language-toml">
[widgets.header]
  widget = "include"
  file = "templates/header.html"
  selector = "#header"

[widgets.footer]
  widget = "include"
  file = "templates/footer.html"
  selector = "#footer"
</pre>
<p>
This widget provides a <code>parse</code> option that controls whether the file is parsed
or included as a text node. Use <code>parse = false</code> if you want to include a file verbatim,
with HTML special characters escaped.
</p>

<h4 id="widgets-insert_html">insert_html</h4>
<p>For a small HTML snippet, a separate file may be too much. The <code>insert_html</code> widget </p>
<pre class="language-toml">
[widgets.tracking-script]
  widget = "insert_html"
  html = '&lt;script src="/scripts/evil-analytics.js"&gt; &lt;/script&gt;'
  selector = "head"
</pre>

<h4 id="widgets-exec">exec</h4>
<p>
The <code>exec</code> widget executes an external program and includes its output into
an element. The program is executed in shell, so you can write a complete command
with arguments in the <code>command</code> option. Like the <code>include</code>
widget, it has a <code>parse</code> option that includes the output verbatim
if set to <code>false</code>.
</p>
<p>Simple example: page generation timestamp.</p>
<pre class="language-toml">
[widgets.generated-on]
  widget = "exec"
  selector = "#generated-on"
  command = "date -R"
</pre>

<h4 id="widgets-preprocess-element">preprocess_element</h4>
<p>
This widget processes element content with an external program and includes
its output back in the page.
</p>
<p>
Element content is sent to program's stdin, so it can be used with any program
designed to work as a pipe. HTML entities are expanded, so if you have <code>&amp;gt;</code>
or <code>&amp;amp;</code> in your page, the program gets a <code>&gt;</code> and <code>&amp;</code>.
<p>
By default it assumes that the program output is HTML and runs it through an HTML parser.
If you want to include its output as text (with HTML special characters escaped), you should specify <code>parse = false</code>
</p>
<p>
For example, this is how you can run content of <code>&lt;pre&gt;</code> elements through <code>cat -n</code>
to automatically add line numbers:
</p>
<pre class="language-toml">
[widgets.line-numbers]
  widget = "preprocess_element"
  selector = "pre"
  command = "cat -n"
  parse = false
</pre>
<p>
You can pass element metadata to the program for better control. The tag name is passed in the <code>TAG_NAME</code>
environment variable, and all attributes are passed in environment variables prefixed with <code>ATTR</code>:
<code>ATTR_ID</code>, <code>ATTR_CLASS</code>, <code>ATTR_SRC</code>...
</p>
<p>
For example, <a href="http://www.andre-simon.de/">highlight</a>, a popular syntax highlighting tool,
has a language syntax option, e.g. <code>--syntax=python</code>. If your elements that contain
source code samples have language specified in a class (like <code>&lt;pre class="language-python"&gt;</code>),
you can extract the language from the <code>ATTR_CLASS</code> variable like this:
</p>
<pre class="language-toml">
# Runs the content of &lt;* class="language-*"&gt; elements through a syntax highlighter
[widgets.highlight]
  widget = "preprocess_element"
  selector = '*[class^="language-"]'
  command = 'highlight -O html -f --syntax=$(echo $ATTR_CLASS | sed -e "s/language-//")'
</pre>
<p>
Like all widgets, this widget supports the <a href="#choosing-where-to-insert-the-output">action</a> option. The default is
<code>action = "replace_content"</code>, but using different actions you can insert a rendered version
of the content alongside the original. For example, insert an inline SVG version of every <a href="https://graphviz.org/">Graphviz</a>
graph next to the source, and then highlight the source:
</p>
<pre class="language-toml">
[widgets.graphviz-svg]
  widget = 'preprocess_element'
  selector = 'pre.language-graphviz'
  command = 'dot -Tsvg'
  action = 'insert_after'

[widgets.highlight]
  after = "graphviz-svg"
  widget = "preprocess_element"
  selector = '*[class^="language-"]'
  command = 'highlight -O html -f --syntax=$(echo $ATTR_CLASS | sed -e "s/language-//")'
</pre>
<p>The result will look like this:</p>
<img src="/images/graphviz_sample.png"></img>

<p><strong>Note:</strong> this widget supports multiple selectors, e.g. <code>selector = ["pre", "code"]</code>.</p>

<h4>Environment variables</h4>
<p>
External programs executed by <code>exec</code> and <code>preprocess_element</code> widgets get
a few useful environment variables:
</p>
<dl>
  <dt><code>PAGE_FILE</code></dt>
  <dd>Path to the page source file, relative to the current working directory
      (e.g. <code>site/index.html</code></dd>
  <dt><code>TARGET_DIR</code></dt>
  <dd>The directory where the rendered page will be saved.</dd>
</dl>
<p>This is how you can include page's own source into a page, on a UNIX-like system:</p>
<pre class="language-toml">
[widgets.page-source]
  widget = "exec"
  selector = "#page-source"
  parse = false
  command = "cat $PAGE_FILE"
</pre>
<p>
If you store your pages in git, you can get a page timestamp from the git log
with a similar method (note that it's not a very fast operation for long commit
histories):
<pre class="language-toml">
[widgets.last-modified]
  widget = "exec"
  selector = "#git-timestamp"
  command = "git log -n 1 --pretty=format:%ad --date=format:%Y-%m-%d -- $PAGE_FILE"
</pre>
<p>
The <code>PAGE_FILE</code> variable can be used in many different ways,
for example, you can use it to fetch the page author and modification date
from a revision control system like git or mercurial.
</p>
<p>
The <code>TARGET_DIR</code> variable is useful for scripts that modify or create page assets.
For example, this snippet will create PNG images from <a href="https://graphviz.org">Graphviz</a> graphs
inside <code>&lt;pre class="graphviz-png"&gt;</code> elements and replace those pre's with relative
links to images.
</p>
<pre class="language-toml">
[widgets.graphviz-png]
  widget = 'preprocess_element'
  selector = '.graphviz-png'
  command = 'dot -Tpng &gt; $TARGET_DIR/graph_$ATTR_ID.png && echo \&lt;img src="graph_$ATTR_ID.png"\&gt;'
  action = 'replace_element'
</pre>

<h3>Content manipulation</h3>
<h4 id="widgets-title">title</h4>
<p>
The <code>title</code> widget sets the page title, that is, the <code>&lt;title&gt;</code>
from an element with a certain selector. If there is no <code>&lt;title&gt;</code> element
in the page, this widget assumes you don't want it and does nothing.
</p>
<p>Example:</p>
<pre class="language-toml">
[widgets.page-title]
  widget = "title"
  selector = "h1"
  default = "My Website"
  append = " on My Website"
  prepend = "Page named "
</pre>
<p>
If <code>selector</code> is not specified, it uses the first <code>&lt;h1&gt;</code>
as the title source element by default.
</p>
<p>
The <code>selector</code> option can be a list. For example, <code>selector = ["h1", "h2", "#title"]</code>
means &ldquo;use the first <code>&lt;h1&gt;</code> if the page has it, else use <code>&lt;h2&gt;</code>,
else use anything with <code>id="title"</code>, else use default&rdquo;.
</p>
<p>
Optional <code>prepend</code> and <code>append</code> parameters allow you to insert some text
before and after the title.
</p>
<p>
If there is no element matching the <code>selector</code> in the page, it will use the
title specified in <code>default</code> option. In that case the <code>prepend</code>
and <code>append</code> options are ignored.
</p>
<p>
If the title source element is absent and default title is not set, the title is left empty.
</p>

<h4 id="widgets-footnotes">footnotes</h4>
<p>
The <code>footnotes</code> widget finds all elements matching a selector,
moves them to a designated footnotes container, and replaces them with numbered links.<span class="footnote" id="footnotes">As if anyone doesn't know what what's a footnote.</span>
As usual, the container element can be anywhere in the page—you can have footnotes at the top if you feel like it.
</p>
<pre class="language-toml">
[widgets.footnotes]
  widget = "footnotes"

  # Required: Where to move the footnotes
  selector = "#footnotes"

  # Required: What elements to consider footnotes
  footnote_selector = ".footnote"

  # Optional: Element to wrap footnotes in, default is &lt;p&gt;
  footnote_template = "&lt;p&gt; &lt;/p&gt;"

  # Optional: Element to wrap the footnote number in, default is &lt;sup&gt;
  ref_template = "&lt;sup&gt; &lt;/sup&gt;"

  # Optional: Class for footnote links, default is none
  footnote_link_class = "footnote"

  # Optional: do not create links back to original locations
  back_links = true

  # Prepends some text to the footnote id
  link_id_prepend = ""

  # Appends some text to the back link id
  back_link_id_append = ""
</pre>
<p>
The <code>footnote_selector</code> option can be a list, in that case all elements
matching any of those selectors will be considered footnotes.
</p>
<p>
By default, the number in front of a footnote is a hyperlink back to the original
location. You can disable it and make footnotes one way links with <code>back_links = false</code>.
</p>
<p>
You can create a custom &ldquo;namespace&rdquo; for footnotes and reference links using the <code>link_id_prepend</code> and <code>back_link_id_append</code> options.
This makes it easier to use custom styling for those elements.
</p>
<pre class="language-toml">
link_id_prepend = "footnote-"
back_link_id_append = "-ref"
</pre>

<h4 id="widgets-toc">toc</h4>
<p>The <code>toc</code> widget generates a table of contents for your page.</p>
<p>
Table of contents is generated from the heading tags from <code>&lt;h1&gt;</code>
to <code>&lt;h6&gt;</code>. 
</p>
<p>Here is the ToC configuration from this website:</p>
<pre class="language-toml">
[widgets.table-of-contents]
  widget = "toc"

  # Required: where to insert the ToC
  selector = "#generated-toc"

  # Optional: minimum and maximum levels, defaults are 1 and 6 respectively
  min_level = 2
  max_level = 6

  # Optional: use &lt;ol&gt; instead of &lt;ul&gt; for ToC lists
  # Default is false
  numbered_list = false

  # Optional: Class for the ToC list element, default is none
  toc_list_class = "toc"

  # Optional: append the heading level to the ToC list class
  # In this example list for level 2 would be "toc-2"
  toc_class_levels = false

  # Optional: Insert "link to this section" links next to headings
  heading_links = true

  # Optional: text for the section links
  # Default is "#"
  heading_link_text = "→ "

  # Optional: class for the section links
  # Default is none
  heading_link_class = "here"

  # Optional: insert the section link after the header text rather than before
  # Default is false
  heading_links_append = false

  # Optional: use header text slugs for anchors
  # Default is false
  use_heading_slug = true

  # Optional: use unchanged header text for anchors
  # Default is false
  use_heading_text = false

  # Place nested lists inside a &lt;li&gt; rather than next to it
  valid_html = false
</pre>
<h6>Choosing the heading anchor options</h6>
<p>
For the table of contents to work, every heading needs a unique <code>id</code>
attribute that can be used as an anchor.
</p>
<p>
If a heading has an <code>id</code> attribute, it will be used for the anchor.
If it doesn't, soupault has to generate one.
</p>
<p>
By default, if a heading has no <code>id</code>, soupault will generate
a unique numeric identifier for it.<span class="footnote">Much like the footnotes widget.</span>
This is safe, but not very good for readers (links are non-indicative) and for people who want to share
direct links to sections (they will change if you add more sections).
</p>
<p>
If you want to find a balance between readability, permanence, and ease of maintenance,
there are a few ways you can do it and the choice is yours.
</p>
<p>
The <code>use_heading_slug = true</code> option converts the heading text
to a valid HTML identifier. Right now, however, it's very aggressive
and replaces everything other than ASCII letters and digits with hyphens.
This is obviously a no go for non-ASCII languages, that is, pretty much
all languages in the world. It may be implemented more sensibly in the future.
</p>
<p>
The <code>use_heading_text = true</code> option uses unmodified heading text
for the <code>id</code>, with whitespace and all. This is against the rules of HTML,
but seems to work well in practice.
</p>
<p>
Note that <code>use_heading_slug</code> and <code>use_heading_text</code>
do not enforce uniqueness.
</p>
<p>
All in all, for best link permanence you should give every heading a unique id
by hand, and for best readability you may want to go with <code>use_heading_text = true</code>.
</p>

<h4 id="widgets-breadcrumbs">breadcrumbs</h4>
<p>The <code>breadcrumbs</code> widget generates breadcrumbs for the page.</p>
<p>The only required parameter is <code>selector</code>, the rest is optional.</p>
<pre class="language-toml">
[widgets.breadcrumbs]
  widget = "breadcrumbs"

  selector = "#breadcrumbs"
  prepend = ".. / "
  append = " /"
  between = " / "
  breadcrumb_template = "<a class=\"nav\"></a>"
  min_depth = 1
</pre>
<p>
The <code>breadcrumb_template</code> is an HTML snippet that can be used
for styling your breadcrumbs.
It <strong>must</strong> have an <code>&lt;a&gt;</code> element in it.
By default, a simple unstyled link is used.
</p>
<p>
The <code>min_depth</code> sets the minimum nesting depth where breadcrumbs
appear. That's the length of the logical navigation path rather than directory path.
</p>
<p>
There is a fixup that decrements the path for section index pages, that is, pages named<code>index</code>
by default, or whatever is specified in the <code>index_page</code> option.
Their navigation path is considered one level shorter than any other page in the section,
when clean URLs are used. This is to prevent section index pages from having links
to themselves.
</p>
<ul>
  <li><code>site/index.html</code> → 0</li>
  <li><code>site/foo/index.html</code> → 0 (sic!)</li>
  <li><code>site/foo/bar.html</code> → 1</li>
</ul>

<h3>HTML manipulation</h3>

<h4>delete_element</h4>

<p>The opposite of <code>insert_html</code>. Deletes an element that matches a selector. It can be useful in two situations:</p>
<ul>
  <li>Another widget may leave an element empty and you want to clean it up.</li>
  <li>Your pages are generated with another tool and it inserts something you don't want.</li>
</ul>
<pre class="language-toml">
# Who reads footers anyway?
[widgets.delete_footer]
  widget = "delete_element"
  selector = "#footer"
</pre>
<p>
You can limit it to deleting only empty elements with <code>only_if_empty = true</code> option.
Element is considered empty if there's nothing but whitespace inside it.
</p>
<p>
It's possible to delete only the first element matching a selector by adding <code>delete_all = false</code>
to its config.
</p>

<h2>Plugins</h2>

<p>
Since version 1.2, soupault can be extended with Lua plugins. Currently there are following limitations:
</p>
<ul>
  <li>The supported language is Lua 2.5, not modern Lua 5.x. That means no closures and no <code>for</code> loops in particular.
      Here's a copy of the Lua 2.5 <a href="https://soupault.neocities.org/files/lua-2.5-refman.pdf">reference manual</a>.</li>
  <li>Only string and integer options can be passed to plugins via widget options from <code>soupault.conf</code></li>
</ul>
<p>
Plugins are treated like widgets and are configured the same way.
</p>
<p>You can find ready to use plugins in the <a href="/plugins">Plugins</a> section on this site.</p>

<h3>Installing plugins</h3>
<h4>Plugin discovery</h4>
<p>
By default, soupault looks for plugins in the <code>plugins/</code> directory.
Suppose you want to use the <a href="/plugins/#site-url">Site URL</a> plugin.
To use that plugin, save it to <code>plugins/site-url.lua</code>. Then a widget named <code>site-url</code>
will automatically become available.
The <code>site_url</code> option from the widget config
will be accessible to the plugin as <code>config["site_url"]</code>.
</p>
<pre class="language-toml">
[widgets.absolute-urls]
  widget = "site-url"
  site_url = "https://www.example.com"
</pre>
<p>
You can specify multiple plugin directories using the <code>plugin_dirs</code> option under <code>[settings]</code>:
</p>
<pre class="language-toml">
[settings]
  plugin_dirs = ["plugins", "/usr/share/soupault/plugins"]
</pre>
<p>
If a file with the same name is found in multiple directories, soupault will use the file from the first
directory in the list.
</p>
<p>
You can also disable plugin discovery and load all plugins explicitly.
</p>
<pre class="language-toml">
[settings]
  plugin_discovery = false
</pre>
<h4>Explicit plugin loading</h4>
<p>
You can also load plugins explicitly. This can be useful if you want to:
</p>
<ul>
  <li>load a plugin from an unusual directory</li>
  <li>use a widget name not based on the plugin file name</li>
  <li>override a built-in widget with a plugin</li>
</ul>
<p>Suppose you want to associate the <code>site-url.lua</code> plugin with <code>absolute-links</code> widget name. Add this snippet to <code>soupault.conf</code>:</p>
<pre class="language-toml">
[plugins.absolute-links]
  file = "plugins/site-url.lua"
</pre>
<p>It will register the plugin as a widget named <code>absolute-links</code>.</p>
<p>
Then you can use it like any other widget. Plugin subtable name becomes the name of the widget,
in our case <code>absolute-links</code>.
</p>
<pre class="language-toml">
[widgets.make-urls-absolute]
  widget = "absolute-links"
  site_url = "https://www.example.com"
</pre>

<p>If you want to write your own plugins, read on.</p>

<h3>Plugin example</h3>
<p>
Here's the source of that Site URL plugin that converts relative links to absolute URLs by prepending a site URL to them:
</p>

<pre class="language-lua">
-- Converts relative links to absolute URLs
-- e.g. "/about" -> "https://www.example.com/about"

-- Get the URL from the widget config
site_url = config["site_url"]

if not Regex.match(site_url, "(.*)/$") then
  site_url = site_url .. "/"
end

links = HTML.select(page, "a")

-- Lua array indices start from 1
local index = 1
while links[index] do
  link = links[index]
  href = HTML.get_attribute(link, "href")
  if href then
    -- Check if URL schema is present
    if not Regex.match(href, "^([a-zA-Z0-9]+):") then
      -- Remove leading slashes
      href = Regex.replace(href, "^/*", "")
      href = site_url .. href
      HTML.set_attribute(link, "href", href)
    end
  end
  index = index + 1
end
</pre>

<p>In short:</p>
<ul>
  <li>Widget options can be retrieved from the <code>config</code> hash table.</li>
  <li>The element tree of the page is in the <code>page</code> variable. You can think of it as an equivalent of <code>document</code> in JavaScript.</li>
  <li><code>HTML.select()</code> function is like <code>document.querySelectorAll</code> in JS.</li>
  <li>The <code>HTML</code> module provides an API <em>somewhat</em> similar to DOM API in browsers, though it's procedural rather than object-oriented.</li>
</ul>

<h3>Plugin environment</h3>
<p>Plugins have access to the following global variables:</p>
<dl>
  <dt><code>page</code></dt>
  <dd>The page element tree that can be manipulated with functions from the <code>HTML</code> module.</dd>
  <dt><code>page_file</code></dt>
  <dd>Page file path, e.g. <code>site/index.html</code></dd>
  <dt><code>target_dir</code>
  <dd>The directory where the page file will be saved, e.g. <code>build/about/</code>.</dd>
  <dt><code>nav_path</code></dt>
  <dd>List of strings representing the logical navigation path. For example, for <code>site/foo/bar/quux.html</code>
      it's <code>["foo", "bar"]</code>.
  <dt><code>page_url</code></dt>
  <dd>Relative page URL, e.g. <code>/articles</code> or <code>/articles/index.html</code>, depending on the <code>clean_urls</code> setting.</dd>
  <dt><code>config</code></dt>
  <dd>A table with widget config options.</dd>
</dl>

<p>
<strong>Note:</strong> only string and integer options can be passed to plugins through the <code>config</code> table.
You <em>cannot</em> pass TOML lists or inline tables to plugins in the current soupault version.
You <em>sort of</em> can pass booleans, but they will be converted to strings <code>"true"</code> and <code>"false"</code>,
so you need to compare explicitly.
</p>

<h3>Plugin API</h3>
<p>
Apart from the standard Lua 2.5 functions, soupault provides additional modules.</p>
<h4>The HTML module</h4>
<h5><code>HTML.parse(string)</code></h5>
<p>Example: <code>h = HTML.parse("&lt;p&gt;hello world&lt;p&gt;")</code></p>
<p>Parses a string into an HTML element tree</p>

<h5><code>HTML.create_element(tag, text)</code></h5>
<p>Example: <code>h = HTML.create_element("p", "hello world")</code></p>
<p>Creates an HTML element node.</p>

<h5><code>HTML.create_text(string)</code></h5>
<p>Example: <code>h = HTML.create_text("hello world")</code></p>
<p>
Creates a text node that can be inserted into the page just like element nodes. This function automatically escapes all HTML special characters inside the string.
</p>

<h5><code>HTML.inner_html(html)</code></h5>
<p>Example: <code>h = HTML.inner_html(HTML.select(page, "body"))</code></p>
<p>Returns element content as a string.</p>

<h5><code>HTML.strip_tags(html)</code></h5>
<p>Example: <code>h = HTML.strip_tags(HTML.select(page, "body"))</code></p>
<p>Returns element content as a string, with all HTML tags removed.</p>

<h5><code>HTML.select(html, selector)</code></h5>
<p>Example: <code>links = HTML.select(page, "a")</code></p>
<p>Returns a list of elements matching specified selector.</p>

<h5><code>HTML.select_one(html, selector)</code></h5>
<p><code>content_div = HTML.select(page, "div#content")</code></p>
<p>Returns the first element matching specified selector, or <code>nil</code> if none are found.</p>

<h5><code>HTML.select_any_of(html, selectors)</code></h5>
<p>Example: <code>link_or_pic = HTML.select_any_of(page, {"a", "img"})</code></p>
<p>Returns the first element matching any of specified selectors.</p>

<h5><code>HTML.select_all_of(html, selectors)</code></h5>
<p>Example: <code>links_and_pics = HTML.select_all_of(page, {"a", "img"})</code></p>
<p>Returns all elements matching any of specified selectors.</p>

<p>Returns element's parent.</p>
<p>Example: if there's an element that has a <code>&lt;blink&gt;</code> in it, insert a warning just before that element.</p>
<pre class="language-lua">
blink_elem = HTML.select_one(page, "blink")
if elem then
  parent = HTML.parent(blink_elem)
  warning = HTML.create_element("p", "Warning: blink element ahead!")
  HTML.insert_before(parent, warning)
end
</pre>

<h5>Access to surrounding elements</h5>
<p>
This family of functions provides access to element's neighboring elements in the tree.
They all return a (possibly empty) list.
</p>
<ul>
  <li><code>HTML.children</code></li>
  <li><code>HTML.ancestors</code></li>
  <li><code>HTML.descendants</code></li>
  <li><code>HTML.siblings</code></li>
</ul>
<p>Example: add <code>class="silly-class"</code> to every element inside the page <code>&lt;body&gt;</code>.</p>
<pre class="language-lua">
body = HTML.select_one(page, "body")
children = HTML.children(body)

local i = 1
while children[i] do
  if HTML.is_element(children[i]) then
    HTML.add_class(children[i], "silly-class")
  end
  i = i + 1
end
</pre>

<h5><code>HTML.is_element</code></h5>
<p>
Web browsers provide a narrower API than general purpose HTML parsers. In the JavaScript DOM API, <code>element.children</code>
provides access to all <em>child elements</em> of an element.
</p>
<p>
However, in the HTML parse tree, the picture is more complex. Text nodes are also child nodes—browsers just filter those out
because JavaScript code rarely has a need to do anything with text nodes.
</p>
<p>
Consider this HTML: <code>&lt;p&gt;This is a &lt;em&gt;great&lt;/em&gt; paragraph&lt;/p&gt;</code>. How many children does
the <code>&lt;p&gt;</code> element have? In fact, <em>three</em>: <code>text("This is a "), element("em", "great"), text(" paragraph")</code>.
</p>
<p>
The goal of soupault is to allow modifying HTML pages in any imaginable way, so it cannot ignore this complexity. Many operations like
<code>HTML.add_class</code> still make no sense for text nodes, so there has to be a way to check if something is an element or not.
</p>
<p>
That's where <code>HTML.is_element</code> comes in handy.
</p>

<h5><code>HTML.get_attribute(html_element, attribute)</code></h5>
<p>Example: <code>href = HTML.get_attribute(link, "href")</code></p>
<p>
Returns the value of an element attribute. The first argument must be an element reference
produced by <code>HTML.select/HTML.select_one/HTML.select_element</code>
</p>
<p>
If the attribute is missing, it returns <code>nil</code>. If the attribute is present but
its value is empty (like in <code>&lt;elem attr=""&gt;</code> or <code>&lt;elem attr&gt;</code>),
it returns an empty string. In Lua, both empty string and <code>nil</code> are false for the purpose of <code>if value then ... end</code>,
so if you want to check for <em>presence</em> of an attribute regardless of its value, you should
explicitly check for <code>nil</code>.
</p>

<h5><code>HTML.set_attribute(html_element, attribute)</code></h5>
<p>Example: <code>HTML.set_attribute(content_div, "id", "content")</code></p>
<p>
Sets an attribute value. The first argument must be an element reference
produced by <code>HTML.select/HTML.select_one/HTML.select_element</code>
</p>

<h5><code>HTML.add_class(html_element, class_name)</code></h5>
<p>Example: <code>HTML.add_class(p, "centered")</code></p>
<p>
Adds a <code>class="class_name"</code> attribute. The first argument must be an element reference
produced by <code>HTML.select/HTML.select_one/HTML.select_element</code>
</p>

<h5><code>HTML.remove_class(html_element, class_name)</code></h5>
<p>Example: <code>HTML.remove_class(p, "centered")</code></p>
<p>
Adds a <code>class="class_name"</code> attribute. The first argument must be an element reference
produced by <code>HTML.select/HTML.select_one/HTML.select_element</code>
</p>

<h5><code>HTML.get_tag_name(html_element)</code></h5>
<p>Returns the tag name of an element.</p>
<p>Example: <code>link_or_pic = HTML.select_any_of(page, {"a", "img"}); tag_name = HTML.get_tag_name(link_of_pic)</code> </p>

<h5><code>HTML.set_tag_name(html_element)</code></h5>
<p>Changes the tag name of an element.</p>
<p>Example: &rdquo;modernize&rdquo; <code>&lt;blink&gt;</code> elements by converting them to <code>&lt;span class="blink"&gt;</code>.</p>
<pre class="language-lua">
blinks = HTML.select(page, "blink")

local i = 1
while blinks[i] do
  elem = blinks[i]
  HTML.set_tag_name(elem, "span")
  HTML.add_class(elem, "blink")

  i = i + 1
end
</pre>

<h5><code>HTML.append_child(parent, child)</code></h5>
<p>Example: <code>HTML.append_child(page, HTML.create_element("br"))</code></p>
<p>Appends a child element to the parent.</p>

<p>
Apart from <code>HTML.append_child</code>, there's a family of functions that insert an element at a different position in the tree:
<code>HTML.prepend_child</code>, <code>HTML.insert_before</code>, <code>HTML.insert_after</code>, <code>HTML.replace_element</code>,
and <code>HTML.replace_content</code>.
</p>

<h5><code>HTML.delete(html_element)</code></h5>
<p>Example: <code>HTML.delete(HTML.select_one(page, "h1"))</code></p>
<p>Deletes an element from the page. The argument must be an element reference returned by a select function.</p>

<h5><code>HTML.delete_content(html_element)</code></h5>
<p>Deletes all children of an element (but leaves the element itself in place).</p>

<h5><code>HTML.clone_content(html_element)</code></h5>
<p>Creates a new element tree from the content of an element.</p>
<p>Useful for duplicating an element elsewhere in the page.</p>

<h5><code>HTML.get_heading_level(html_element)</code></h5>
<p>For elements whose tag name matches <code>&lt;h[1-9]&gt;</code> pattern, returns the heaving level.</p>
<p>Returns zero for elements whose tag name doesn't look like a heading and for values that aren't HTML elements.</p>

<h5><code>HTML.get_headings_tree(html_element)</code></h5>
<p>Returns a table that represents the tree of HTML document headings in a format like this:.</p>
<pre>
[
  {
    "heading": ...,
    "children": [
      {"heading": ..., "children": []}
    ]
  },
  {"heading": ..., "children": []}
]
</pre>
<p>
Values of the <code>heading</code> fields are HTML element references.
</p>

<h5>Behaviour</h5>
<p>
If an element tree access function cannot find any elements (e.g. there are no elements that match a selector),
it returns <code>nil</code>.
</p>
<p>
If a function that expects an HTML element receives <code>nil</code>, it immediately returns <code>nil</code>,
so you don't need to check for <code>nil</code> at every step and can safely chain calls to those functions.
</p>

<h4>The Regex module</h4>
<p>
Regular expressions used by this module are mostly Perl-compatible. Capturing groups and back references are not supported.
</p>

<h5><code>Regex.match(string, regex)</code></h5>
<p>Example: <code>Regex.match("/foo/bar", "^/")</code></p>
<p>Checks if a string matches a regex.</p>

<h5><code>Regex.find_all(string, regex)</code></h5>
<p>Example: <code>matches = Regex.find_all("/foo/bar", "([a-z]+)")</code></p>
<p>Returns a list of substrings matching a regex.</p>

<h5><code>Regex.replace(string, regex, string)</code></h5>
<p>Example: <code>s = Regex.replace("/foo/bar", "^/", "")</code></p>
<p>Replaces the first occurrence of a matching substring. It returns a new string and doesn't modify the argument.</p>

<h5><code>Regex.replace_all(string, regex, string)</code></h5>
<p>Example: <code>Regex.replace_all("/foo/bar", "/", "")</code></p>
<p>Replaces every matching substring. It returns a new string and doesn't modify the argument.</p>

<h5><code>Regex.split(string, regex)</code></h5>
<p>Example: <code>substrings = Regex.find_all("foo/bar", "/")</code></p>
<p>Splits a strings at a separator.</p>

<h4>The Plugin module</h4>
<p>Provides functions for communicating with the plugin runner code.</p>

<h5><code>Plugin.fail</code></h5>
<p>Example: <code>Plugin.fail("Error occurred")</code></p>
<p>Stops plugin execution immediately and signals an error. Errors raised this way are treated as widget processing errors by soupault, for the purpose of the <code>strict</code> option.</p>

<h5><code>Plugin.exit</code></h5>
<p>Example: <code>Plugin.exit("Nothing to do")</code>, <code>Plugin.exit()</code></p>
<p>Stops plugin execution immediately. The message is optional. This kind of termination is not considered an error by soupault.</p>

<h5><code>Plugin.require_version</code></h5>
<p>Example: <code>Plugin.require_version("1.8.0")</code></p>
<p>
Stops plugin execution if soupault version is less than required version. You can give a full version like 1.9.0 or a short version like 1.9.
This function was introduced in 1.8, so plugins that use it will fail to work in 1.7 and below.
</p>

<h4>The Sys module</h4>

<h5><code>Sys.read_file</code></h5>
<p>Example: <code>Sys.read_file("site/index.html")</code></p>
<p>Reads a file into a string. The path is relative to the working directory.</p>

<h5><code>Sys.run_program(command)</code></h5>
<p>Executes given command in the system shell (<code>/bin/sh</code> on UNIX, <code>cmd.exe</code> on Windows).</p>
<p>The output of the command is ignored. If command fails, its stderr is logged.</p>
<p>Example: creating a silly file in the directory where generated page will be stored.</p>
<pre class="language-lua">
res = Sys.run_program(format("echo \"Kilroy was here\" > %s/graffiti", target_dir))
if not res then
  Log.warning("Damn, busted")
end
</pre>
<p>
The intended use case for it is creating and processing assets, e.g. converting images to different formats.
</p>

<h5><code>Sys.get_program_output(command)</code></h5>
<p>Executes a command in the system shell and returns its output.</p>
<p>
If the command fails, it returns <code>nil</code>. The stderr is shown in the execution log,
but there's no way a plugin can access its stderr or the exit code.
</p>
<p>Example: getting the last modification date of a page from git.</p>
<pre class="language-lua">
git_command = "git log -n 1 --pretty=format:%ad --date=format:%Y-%m-%d -- " .. page_file
timestamp = Sys.get_program_output(git_command)

if not timestamp then
  timestamp = "1970-01-01"
end
</pre>

<h5><code>Sys.random(max)</code></h5>
<p>Example: <code>Sys.random(1000)</code></p>
<p>Generates a random number from 0 to max.</p>

<h5><code>Sys.is_unix ()</code></h5>
<p>Returns true on UNIX-like systems (Linux, Mac OS, BSDs), false otherwise.</p>

<h5><code>Sys.is_windows ()</code></h5>
<p>Returns true on Microsoft Windows, false otherwise.</p>

<h4>The String module</h4>

<h5><code>String.trim</code></h5>
<p>Example: <code>String.trim(" my string ") -- produces "my string"</code></p>
<p>Removed leading and trailing whitespace from a string.</p>

<h5><code>String.slugify_ascii</code></h5>
<p>Example: <code>String.slugify_ascii("My Heading") -- produces "my-heading" </code></p>
<p>Replaces all characters other than English letters and digits with hyphens, exactly like the <a href="#widgets-toc">ToC widget</a>.</p>

<h5><code>String.truncate(string, length)</code></h5>
<p>Truncates a string to given length.</p>
<p>Example: <code>String.truncate("foobar", 3) -- "foo"</code>.</p>

<h5><code>String.to_number</code></h5>
<p>Example: <code>String.to_number("2.7") -- produces 2.7 (float)</code></p>
<p>Converts strings to numbers. Returns <code>nil</code> is a string isn't a valid representation of a number.</p>

</div>
</div>
