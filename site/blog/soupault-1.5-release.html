<h1 id="post-title">Soupault 1.5 (it can work with unmodified websites as an HTML processor now)</h1>

<span>Date: <time id="post-date">2019-11-01</time> </span>

<p>
One hard limitation of classic website generators is that pages with unique layouts are excluded from any processing.
You can add them as static assets, but you can&apos;t have template tags inside them.
</p>
<p>
Soupault used to have a soft version of that limitationâ€”you could make unique pages by using a bare minimum template like
<code>&lt;html&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt;</code>
and keeping most of the layout inside page content files, but for sites where most pages are not unique, it would create
lots of duplicate code. That was clearly contrary to the goals of being friendly to Web 1.0 style sites that feature unique pages
and making it easy to automate <em>just</em> what you want to automate.
</p>
<p>
Another problem was that you&apos;d have to edit every page and strip it to the content just to give soupault a try. You could not
take advantage of soupault&apos;s HTML processing capabilities without switching to the
&ldquo;empty page plus page bodies&rdquo; workflow first. However, functionality like tables of contents,
footnotes, file/snippet/script output insertion and so on could easily work with unmodified pages, so that limitation
was artificial and unjustified. In this release I focused on removing that limitation.
</p>
<p id="post-excerpt">
Soupault 1.5 is easy to try out without modifying any existing page. It&apos;s now able to detect
if a file is a page body or a complete page. Page bodies are inserted in the template,
but complete pages are just processed by widgets/plugins. Moreover, there&apos;s now an &ldquo;HTML processor mode&rdquo;
when it needs no template at all. Now it&apos;s much easier to make websites where many pages have a unique layout,
or use soupault to automatically enhance an existing site, e.g. inject a viewport meta tag or a table of contents into every page,
or add an autogenerated list of all pages.
</p>
<p>
You can download the executables from <a href="https://files.baturin.org/software/soupault/1.5/">files.baturin.org/software/soupault/1.5/</a>.
</p>
<h2>Complete pages vs page bodies</h2>
<p>
Earlier versions assumed that everything in <code>site/</code> is a page body that should be inserted into the template. If you tried
to put a complete page there, it would cheerfully insert it into the template and create a page with one <code>&lt;html&gt;</code>
nested inside another, which is patent nonsense.
</p>
<p>
Now it checks if a page has an <code>&lt;html&gt;</code> tag in it. If it does, it runs the page through the widgets and saves to disk.
If it doesn&apos;t, then the page is first inserted in the template, then processed by widgets and saved to disk.
</p>
<p>
This way you can easily try soupault on your existing website. Run <code>soupault --init</code>, copy your existing pages to <code>site/</code>,
tweak the <code>soupault.conf</code> config, run <code>soupault</code>, and check out the output in <code>build/</code>.
</p>
<p>
Then you can either gradually migrate to a workflow with a shared template file for non-unique pages, or keep everything as is,
the choice is yours.
</p>
<p>
The element whose presence tells soupault that a file is a complete page is configurable. You can change it from <code>&lt;html&gt;</code>
to <code>&lt;body&gt;</code> or something else if you want.
</p>
<pre class="language-toml">
[settings]
  complete_page_selector = "html"
</pre>
<h2>HTML processor mode</h2>
<p>
A website where every page is unique (or there&apos;s just one page), or the HTML is generated by something else is also a valid use case.
With complete page detection feature, nothing prevents you from using it as a configurable/programmable HTML processor rather than
a website generator in the usual sense.
</p>
<p>
Now you can switch it to the HTML processor mode with this option:
</p>
<pre class="language-toml">
[settings]
  generator_mode = false
</pre>
<p>
In that mode, it doesn&apos;t require the <code>default_template</code> (usually <code>templates/main.html</code>) to exist and doesn&apos;t use it.
It treats every file in <code>site/</code> as a complete page instead: reads it, runs it through the widgets, and saves to the build directory.
</p>
<h2>Overriding directory locations from the command line</h2>
<p>
If you are to use soupault as an HTML processor, then the concept of &ldquo;project directory&rdquo; becomes meaningless. Even if you are using it
as a website generator, there may also be reasons to change the output directory on the fly, e.g. to deploy your website over WebDAV.
</p>
<p>
Now you can override it all from the command line. Config file location can be set using <code>SOUPAULT_CONFIG</code> environent variable.
Locations of the input and output directories can be set with <code>--site-dir</code> and <code>--build-dir</code> options.
An example of overriding it all at once:
</p>
<pre>
SOUPAULT_CONFIG="something.conf" soupault --site-dir some-input-dir --build-dir some-other-dir
</pre>
<h2>Better control over content insertion</h2>
<p>
Before 1.5, soupault would always append widget output to existing children of the container (i.e. insert it after the last child element).
If you are making a new website with soupault, you&apos;ll probably create designated places for widgets output in your template.
However, if you want to use it with pages not written with that in mind, you need better control of the position where it&apos;s inserted.
Now there&apos;s an option for it.
</p>
<p>
For example, this way you can insert a table of contents right before the first <code>&lt;h1&gt;</code> heading (if a page has it):
</p>
<pre class="language-toml">
[widgets.table-of-contents]
  widget = "toc"
  selector = "h1"
  action = "insert_before"
</pre>
<p>
The <code>action</code> option works for all built-in widgets, except <code>title</code> and <code>delete_element</code> where it makes no sense.
Its possible values are: <code>append_child, prepend_child, insert_before, insert_after, replace_element, replace_content</code>.
</p>
<h2>Other improvements</h2>
<p>
The <code>delete_element</code> widget now deletes all elements matching its selector, unless the <code>delete_all</code> option is <code>false</code>.
</p>
<p>
Autogenerated index is now inserted before widgets run, so that widgets can modify its output.
</p>
<p>
One edge case where this is relevant is footnotes inside paragraphs used as blog post excerpts. Index data extraction happens after all widgets are
processed, so you&apos;d end up with a blog index page full of dangling footnote references. With these changes in place, you can solve that problem
with something like:
</p>
<pre class="language-toml">
[widgets.remove-footnotes-from-excerpts]
  widget = "delete_element"
  selector = "a.footnote"
  page = "blog/index.html"
</pre>
<p>
Also, the default config generated by <code>soupault --init</code> is now more illustrative and well-commented.
</p>
